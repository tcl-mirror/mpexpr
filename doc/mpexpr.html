<!-- manual page source format generated by RosettaMan v3.0.2a9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>mpexpr(TCL) manual page</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
mpexpr - Evaluate an expression with multiple precision math  <P>
 
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS 
</A></H2>
 <P>
<B>package require Mpexpr </B>  <BR>
<B>mpexpr <I>arg  </I></B>?<I>arg arg ... </I>?  <BR>
<B>mpformat <I>formatString 
 </I></B>?<I>arg arg ... </I>?  <BR>
<B>global mp_precision </B>  <P>
 
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION </A></H2>
<P>
Mpexpr is based on Tcl's 
native <I>expr </I> command, and shares many similarities with <I>expr </I>.  Mpexpr 
performs all of its calculations using an arbitrary precision math package. 
<P>
Mpexpr concatenates <I>arg </I>'s (adding separator spaces between them), evaluates 
the result as a Tcl expression, and returns the value. The operators permitted 
in Tcl expressions are a subset of the operators permitted in C expressions, 
and they have the same meaning and precedence as the corresponding C operators. 
Expressions almost always yield numeric results (integer or floating-point 
values). For example, the expression  <P>
<B>mpexpr 8.2 + 6 </B>  <P>
evaluates to 14.2. 
Tcl expressions differ from C expressions in the way that operands are 
specified.  Also, Tcl expressions support non-numeric operands and string 
comparisons.  <P>
 
<H2><A NAME="sect3" HREF="#toc3">OPERANDS </A></H2>
<P>
A Tcl expression consists of a combination of operands, 
operators, and parentheses. White space may be used between the operands 
and operators and parentheses; it is ignored by the expression processor. 
Where possible, operands are interpreted as integer values. Integer values 
may be specified in decimal (the normal case), in octal (if the first 
character of the operand is <B>0 </B>), or in hexadecimal (if the first two characters 
of the operand are <B>0x </B>). If an operand does not have one of the integer 
formats given above, then it is treated as a floating-point number if that 
is possible.  Floating-point numbers may be specified in any of the ways 
accepted by an ANSI-compliant C compiler (except that the ``f'', ``F'', ``l'', and 
``L'' suffixes will not be permitted in most installations).  For example, 
all of the following are valid floating-point numbers:  2.1, 3., 6e4, 7.91e+16. 
If no numeric interpretation is possible, then an operand is left as a 
string (and only a limited set of operators may be applied to it). <P>
Operands 
may be specified in any of the following ways: 
<OL>
<LI>As an numeric value, either 
integer or floating-point. </LI><LI>As a Tcl variable, using standard <B>$ </B> notation. 
The variable's value will be used as the operand. </LI><LI>As a string enclosed in 
double-quotes. The expression parser will perform backslash, variable, and 
command substitutions on the information between the quotes, and use the 
resulting value as the operand </LI><LI>As a string enclosed in braces. The characters 
between the open brace and matching close brace will be used as the operand 
without any substitutions. </LI><LI>As a Tcl command enclosed in brackets. The command 
will be executed and its result will be used as the operand. </LI><LI>As a mathematical 
function whose arguments have any of the above forms for operands, such 
as ``<B>sin($x) </B>''.  See below for a list of defined functions. </LI>
</OL>
<P>
Where substitutions 
occur above (e.g. inside quoted strings), they are performed by the expression 
processor. However, an additional layer of substitution may already have 
been performed by the command parser before the expression processor was 
called. As discussed below, it is usually best to enclose expressions in 
braces to prevent the command parser from performing substitutions on 
the contents. <P>
For some examples of simple expressions, suppose the variable 
<B>a </B> has the value 3 and the variable <B>b </B> has the value 6. Then the command 
on the left side of each of the lines below will produce the value on 
the following line:  <P>

<DL>

<DT><B>mpexpr 3.1 + $a </B>  </DT>
<DD>6.1 </DD>

<DT><B>mpexpr 2 + "$a.$b" </B>  </DT>
<DD>5.6 </DD>

<DT><B>mpexpr 
4*[llength "6 2"] </B>  </DT>
<DD>8 </DD>

<DT><B>mpexpr {{word one} &lt; "word $a"} </B>  </DT>
<DD>0  <BR>
 <P>
</DD>
</DL>
 
<H2><A NAME="sect4" HREF="#toc4">OPERATORS 
</A></H2>
<P>
The valid operators are listed below, grouped in decreasing order of precedence: 

<DL>

<DT><B>-  +  ~  ! </B>  </DT>
<DD>Unary minus, unary plus, bit-wise NOT, logical NOT.  None of 
these operands may be applied to string operands, and bit-wise NOT may 
be applied only to integers. </DD>

<DT><B>*  /  % </B>  </DT>
<DD>Multiply, divide, remainder.  None 
of these operands may be applied to string operands, and remainder may 
be applied only to integers. The remainder will always have the same sign 
as the divisor and an absolute value smaller than the divisor. </DD>

<DT><B>+  - </B>  </DT>
<DD>Add 
and subtract.  Valid for any numeric operands. </DD>

<DT><B>&lt;&lt;  &gt;&gt; </B>  </DT>
<DD>Left and right shift. 
 Valid for integer operands only. Integers in mpexpr are not limited to 
a machine word and do not use two's complement format.  Therefore shifting 
will not include a sign bit. </DD>

<DT><B>&lt;  &gt;  &lt;=  &gt;= </B>  </DT>
<DD>Boolean less, greater, less than 
or equal, and greater than or equal. Each operator produces 1 if the condition 
is true, 0 otherwise. These operators may be applied to strings as well 
as numeric operands, in which case string comparison is used. </DD>

<DT><B>==  != </B>  
</DT>
<DD>Boolean equal and not equal.  Each operator produces a zero/one result. 
Valid for all operand types. </DD>

<DT><B>&amp; </B>  </DT>
<DD>Bit-wise AND.  Valid for integer operands 
only. </DD>

<DT><B>^ </B>  </DT>
<DD>Bit-wise exclusive OR.  Valid for integer operands only. </DD>

<DT><B>| </B>  </DT>
<DD>Bit-wise 
OR.  Valid for integer operands only. </DD>

<DT><B>&amp;&amp; </B>  </DT>
<DD>Logical AND.  Produces a 1 result 
if both operands are non-zero, 0 otherwise. Valid for numeric operands only 
(integers or floating-point). </DD>

<DT><B>|| </B>  </DT>
<DD>Logical OR.  Produces a 0 result if both 
operands are zero, 1 otherwise. Valid for numeric operands only (integers 
or floating-point). </DD>

<DT><I>x<B>?<I>y<B>:<I>z </I></B></I></B></I>  </DT>
<DD>If-then-else, as in C.  If <I>x </I> evaluates to non-zero, 
then the result is the value of <I>y </I>. Otherwise the result is the value of 
<I>z </I>. The <I>x </I> operand must have a numeric value. </DD>
</DL>
<P>
See the C manual for more 
details on the results produced by each operator. All of the binary operators 
group left-to-right within the same precedence level.  For example, the command 
 <P>
<B>mpexpr 4*2 &lt; 7 </B>  <P>
returns 0. <P>
The <B>&amp;&amp; </B>, <B>|| </B>, and <B>?: </B> operators have ``lazy evaluation'', 
just as in C,  which means that operands are not evaluated if they are 
not needed to determine the outcome.  For example, in the command  <P>
<B>mpexpr 
{$v ? [a] : [b]} </B>  <P>
only one of <B>[a] </B> or <B>[b] </B> will actually be evaluated, 
depending on the value of <B>$v </B>.  Note, however, that this is only true if 
the entire expression is enclosed in braces;  otherwise the Tcl parser 
will evaluate both <B>[a] </B> and <B>[b] </B> before invoking the <B>expr </B> command.  <P>
 
<H2><A NAME="sect5" HREF="#toc5">MATH 
FUNCTIONS </A></H2>
<P>
Mpexpr supports the following mathematical functions in expressions. 
<I>x </I> and <I>y </I> are integer or floating point values; <I>i </I>, <I>j </I> and <I>c </I> are integer 
values; <P>
Math functions compatible with <I>expr </I>: 
<DL>

<DT><B>acos(<I>x<B>) </B></I></B>  </DT>
<DD>Arc cosine of 
<I>x </I>. </DD>

<DT><B>asin(<I>x<B>) </B></I></B>  </DT>
<DD>Arc sine of <I>x </I>. </DD>

<DT><B>atan(<I>x<B>) </B></I></B>  </DT>
<DD>Arc tangent of <I>x </I>. </DD>

<DT><B>atan2(<I>x,y<B>) </B></I></B>  </DT>
<DD>Arc 
tangent of <I>x </I> / <I>y </I>. </DD>

<DT><B>ceil(<I>x<B>) </B></I></B>  </DT>
<DD>Least integral value greater than or equal 
to <I>x </I>. </DD>

<DT><B>cos(<I>x<B>) </B></I></B>  </DT>
<DD>Cosine of <I>x </I>. </DD>

<DT><B>cosh(<I>x<B>) </B></I></B>  </DT>
<DD>Hyperbolic cosine of <I>x </I>. </DD>

<DT><B>exp(<I>x<B>) </B></I></B> 
 </DT>
<DD>Exponential function e ** <I>x </I>. </DD>

<DT><B>floor(<I>x<B>) </B></I></B>  </DT>
<DD>Greatest integral value less 
than or equal to <I>x </I>. </DD>

<DT><B>fmod(<I>x,y<B>) </B></I></B>  </DT>
<DD>Remainder of <I>x </I> divided by <I>y </I>. </DD>

<DT><B>hypot(<I>x,y<B>) 
</B></I></B>  </DT>
<DD>Euclidean distance of sqrt( <I>x </I> * <I>x </I> + <I>y </I> * <I>y </I>). </DD>

<DT><B>log(<I>x<B>) </B></I></B>  </DT>
<DD>Natural logarithm 
of <I>x </I>. </DD>

<DT><B>log10(<I>x<B>) </B></I></B>  </DT>
<DD>Base-10 logarithm of <I>x </I>. </DD>

<DT><B>pow(<I>x,y<B>) </B></I></B>  </DT>
<DD><I>x </I> raised to the <I>y 
</I> power. </DD>

<DT><B>sin(<I>x<B>) </B></I></B>  </DT>
<DD>Sine of <I>x </I>. </DD>

<DT><B>sinh(<I>x<B>) </B></I></B>  </DT>
<DD>Hyperbolic sine of <I>x </I>. </DD>

<DT><B>sqrt(<I>x<B>) </B></I></B>  </DT>
<DD>Square 
root of <I>x </I>. </DD>

<DT><B>tan(<I>x<B>) </B></I></B>  </DT>
<DD>Tangent of <I>x </I>. </DD>

<DT><B>tanh(<I>x<B>) </B></I></B>  </DT>
<DD>Hyperbolic tangent of <I>x </I>. </DD>

<DT><B>abs(<I>x<B>) 
</B></I></B>  </DT>
<DD>Returns the absolute value of <I>x </I>.  <I>x </I> may be either integer or floating-point, 
and the result is returned in the same form. </DD>

<DT><B>double(<I>x<B>) </B></I></B>  </DT>
<DD>If <I>x </I> is a floating 
value, returns <I>x </I>, otherwise converts <I>x </I> to floating and returns the converted 
value. </DD>

<DT><B>int(<I>x<B>) </B></I></B>  </DT>
<DD>If <I>x </I> is an integer value, returns <I>x </I>, otherwise converts 
<I>x </I> to integer by truncation and returns the converted value. </DD>

<DT><B>round(<I>x<B>) </B></I></B> 
 </DT>
<DD>If <I>x </I> is an integer value, returns <I>x </I>, otherwise converts <I>x </I> to integer 
by rounding and returns the converted value. </DD>
</DL>
<P>
Additional <I>mpexpr </I> functions: 

<DL>

<DT><B>root(<I>x,y<B>) </B></I></B>  </DT>
<DD>The <I>yth </I> root of <I>x </I>. </DD>

<DT><B>frem(<I>x,y<B>) </B></I></B>  </DT>
<DD>Remove all occurance of factor<I>y 
</I> from number <I>x </I>. </DD>

<DT><B>minv(<I>x,y<B>) </B></I></B>  </DT>
<DD>Inverse of <I>x </I> modulo <I>y </I>. </DD>

<DT><B>gcd(<I>x,y<B>) </B></I></B>  </DT>
<DD>Greatest 
common divisor of <I>x </I> and <I>y </I>. </DD>

<DT><B>lcm(<I>x,y<B>) </B></I></B>  </DT>
<DD>Least common multiple of <I>x </I> and 
<I>y </I>. </DD>

<DT><B>max(<I>x,y<B>) </B></I></B>  </DT>
<DD>Maximum of <I>x </I> and <I>y </I>. </DD>

<DT><B>min(<I>x,y<B>) </B></I></B>  </DT>
<DD>Minimum of <I>x </I> and <I>y </I>. </DD>

<DT><B>pi() 
</B>  </DT>
<DD>Value of pi. </DD>

<DT><B>fib(<I>i<B>) </B></I></B>  </DT>
<DD>Fibonacci number of integer <I>i </I>. </DD>

<DT><B>fact(<I>i<B>) </B></I></B>  </DT>
<DD>Factorial 
of integer <I>i </I>. </DD>

<DT><B>pfact(<I>i<B>) </B></I></B>  </DT>
<DD>Product of prime numbers up to integer <I>i </I>. </DD>

<DT><B>lfactor(<I>i,c<B>) 
</B></I></B>  </DT>
<DD>Lowest prime factor of integer <I>i </I>, trying count <I>c </I> times. </DD>

<DT><B>iroot(<I>i,j<B>) 
</B></I></B>  </DT>
<DD>Integer root <I>j </I> of integer <I>i </I>. </DD>

<DT><B>gcdrem(<I>i,j<B>) </B></I></B>  </DT>
<DD>Relatively prime of greatest 
common divisior of <I>i </I> divided by <I>j </I>. </DD>

<DT><B>perm(<I>i,j<B>) </B></I></B>  </DT>
<DD>Permutations of <I>i </I> taking 
<I>j </I> at a  time: <I>i </I> ! / ( <I>i </I> - <I>j </I> ) !. </DD>

<DT><B>comb(<I>i,j<B>) </B></I></B>  </DT>
<DD>Combinations of <I>i </I> taking 
<I>j </I> at a  time: <I>i </I> ! / ( <I>j </I> ! * ( <I>i </I> - <I>j </I> ) ! ) . </DD>

<DT><B>prime(<I>i,c<B>) </B></I></B>  </DT>
<DD>Return 0 if 
<I>i </I> is not prime, return 1 if <I>i </I>  probably is prime. Test for primality 
count <I>c </I> times.   The chance of a non-prime passing this test is less than 
(1/4)^count. For example, a count of 100 fails for only 1 in 10^60 numbers. 
</DD>

<DT><B>relprime(<I>i,j<B>) </B></I></B>  </DT>
<DD>Return 1 if <I>i </I> and <I>j </I> are relatively prime to each other, 
0 otherwise.  <P>
</DD>
</DL>
 
<H2><A NAME="sect6" HREF="#toc6">TYPES, OVERFLOW, AND PRECISION </A></H2>
<P>
Computations are performed 
using arbitrary fixed and floating point values.  Native machine values 
(<I>int, long, IEEE 754 floating point,  etc.  </I> )  and instructions are not 
used. Conversion among internal representations for integer, floating-point, 
and string operands is done automatically as needed. For arithmetic computations, 
integers are used until some floating-point number is introduced, after 
which floating-point is used. For example,  <P>
<B>mpexpr 5 / 4 </B>  <P>
returns 1, while 
 <P>
<B>mpexpr 5 / 4.0 </B>  <BR>
<B>mpexpr 5 / ( [string length "abcd"] + 0.0 ) </B>  <P>
both return 
1.25. Floating-point values are always returned with a ``.'' or an ``e'' so that they 
will not look like integer values.  For example,  <P>
<B>mpexpr 20.0/5.0 </B>  <P>
returns 
``4.0'', not ``4''.   <P>
The global variable <B>mp_precision </B> determines the number of 
significant digits that are retained during evaluation.    If <B>mp_precision 
</B> is unset then 17 digits of precision are used. The maximum value of <B>mp_precision 
</B> is 10000. Note that larger values for <B>mp_precision </B> will require increasingly 
 longer execution times. Setting <B>mp_precision </B> to an illegal value will 
generate an error.  <P>
 
<H2><A NAME="sect7" HREF="#toc7">STRING OPERATIONS </A></H2>
<P>
String values may be used as operands 
of the comparison operators, although the expression evaluator tries to 
do comparisons as integer or floating-point when it can. If one of the operands 
of a comparison is a string and the other has a numeric value, the numeric 
operand is converted back to a string using the C <I>sprintf </I> format specifier 
<B>%d </B> for integers and <B>%g </B> for floating-point values. For example, the commands 
 <P>
<B>mpexpr {"0x03" &gt; "2"} </B> <B>mpexpr {"0y" &lt; "0x12"} </B>  <P>
both return 1.  The first 
comparison is done using integer comparison, and the second is done using 
string comparison after the second operand is converted to the string 
``18''. Because of Tcl's tendency to treat values as numbers whenever possible, 
it isn't generally a good idea to use operators like <B>== </B> when you really 
want string comparison and the values of the operands could be arbitrary; 
 it's better in these cases to use the <B>string compare </B> command instead. 
<P>
<B>mpformat </B> formats a string in the style  of Tcl's native <I>format </I> command. 
Mpformat will interpret numeric arguments as arbitrary precision numbers. 
Mpformat performs limited % substitution on the output string. The following 
may be specified:  <P>
<B>% [-] [width[.precision]] formatChar </B> <P>

<DL>

<DT><B>- </B>  </DT>
<DD>Specifies left 
justification; right justification is the default. </DD>

<DT><B>width.precision </B>  </DT>
<DD>Specifies 
optional width and precision.  Default precision is 8.   Width and/or precision 
may be specified as <B>* </B>, in which the next argument will be used for the 
width or precision value. </DD>
</DL>
<P>
<B>Format character and result </B> 
<DL>

<DT><B>d </B>  </DT>
<DD>Format next 
argument as integer, truncating after the decimal point. </DD>

<DT><B>f </B>  </DT>
<DD>Format next 
argument in decimal floating point. </DD>

<DT><B>e </B>  </DT>
<DD>Format next argument in scientific 
notation. </DD>

<DT><B>r </B>, <B>R </B>  </DT>
<DD>Format next argument as rational fraction x / y. </DD>

<DT><B>N </B>  </DT>
<DD>Format 
next argument as numerator only of rational fraction x / y. </DD>

<DT><B>D </B>  </DT>
<DD>Format 
next argument as denominator only of rational fraction x / y. </DD>

<DT><B>o </B>  </DT>
<DD>Format 
next argument in octal format, with leading '0'; floating point argument 
formatted as octal rational fraction x / y. </DD>

<DT><B>x </B>  </DT>
<DD>Format next argument in 
hexadecimal format, with leading '0x'; floating  point formatted argument 
as hexadecimal rational fraction x / y. </DD>

<DT><B>b </B>  </DT>
<DD>Format next argument in binary 
format, with leading '0b'; floating point argument formatted as binary rational 
fraction x / y. </DD>

<DT><B>s </B>  </DT>
<DD>Format next argument as string. </DD>

<DT><B>c </B>  </DT>
<DD>Format next argument 
as single character value. </DD>

<DT><B>% </B>  </DT>
<DD>Format single literal %. </DD>
</DL>
<P>
<B>Other characters 
in format string </B> 
<DL>

<DT><B>\n </B>  </DT>
<DD>Format ASCII newline. </DD>

<DT><B>\r </B>  </DT>
<DD>Format ASCII carriage return. 
</DD>

<DT><B>\t </B>  </DT>
<DD>Format ASCII tab. </DD>

<DT><B>\f </B>  </DT>
<DD>Format ASCII form feed. </DD>

<DT><B>\v </B>  </DT>
<DD>Format ASCII vertical 
tab. </DD>

<DT><B>\b </B>  </DT>
<DD>Format ASCII backspace.  <P>
</DD>
</DL>
 
<H2><A NAME="sect8" HREF="#toc8">NOTES </A></H2>
<P>
Mpexpr is based on Tcl 7.6 'tclExpr.c' 
and David Bell's 'Calc' program. This man page is largely borrowed from Tcl 
7.6 as well, as is the  mpexpr test suite.  <P>
See the files README and INSTALL 
for additional information.  <P>
Tcl 7.6 is Copyright (c) 1987-1994 The Regents 
of the University of  California and Copyright (c) 1994 Sun Microsystems, 
Inc.  <P>
Calc is Copyright (c) 1994 David I. Bell.  <P>
 
<H2><A NAME="sect9" HREF="#toc9">AUTHOR </A></H2>
Tom Poindexter, 
tpoindex@nyx.net, Talus Technologies, Inc., Highlands Ranch, CO. <A HREF="http://www.nyx.net/~tpoindex">http://www.nyx.net/~tpoindex</A>
 
 <P>
Version 1.0 released November, 1998.  <P>
Copyright 1998 Tom Poindexter.  See 
the file 'LICENSE.TERMS' for additional copyright and licensing terms. <P>
 <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">OPERANDS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">OPERATORS</A></LI>
<LI><A NAME="toc5" HREF="#sect5">MATH FUNCTIONS</A></LI>
<LI><A NAME="toc6" HREF="#sect6">TYPES, OVERFLOW, AND PRECISION</A></LI>
<LI><A NAME="toc7" HREF="#sect7">STRING OPERATIONS</A></LI>
<LI><A NAME="toc8" HREF="#sect8">NOTES</A></LI>
<LI><A NAME="toc9" HREF="#sect9">AUTHOR</A></LI>
</UL>
</BODY></HTML>
